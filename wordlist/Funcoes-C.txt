bcopy;BufferOverflow;Falha em garantir que o caracter de terminação nao se encontra presente no destino. Uma solucao que melhora substancialmente o problema e utilizar o memcpy().
fscanf;BufferOverflow;E preciso garantir que so se le o numero de dados pretendidos, para nao sobrescrever na memoria. Se mesmo assim pretender usar a funcao, entao use os seguintes "truques" , (...,"%20s",...) - onde vinte e o numero de bytes que a funcao vai ler ou (...,"%as",&string).
getcwd;BufferOverflow;O ponteiro de String nao pode ser NULL, caso contrario tem comportamentos diversos.
getopt;BufferOverflow;Problema quando o numero e tamanho dos argumentos e maior do que o esperado, para tal basta verificar o numero e tamanho dos argumentos recebidos
getpass;BufferOverflow;O problema e baseado na falta do caracter de terminacao ("\0"). Por isso, a solucao e garantir que a cadeia de caracteres tem o caracter de terminacao
gets;BufferOverflow;Utilizar a funcao fgets(), dado que tem o valor maximo a ler de dados, Uma ma utilizacao provoca BufferOverflow.
getwd;BufferOverflow;A String deve ser maior que o tamanho da directoria corrente mais um. A solucao possivel e utilizar getcwd(), que obriga o usuario a especificar o tamanho.
realpath;BufferOverflow;O valor introduzido no primeiro argumento pode indicar um caminho muito grande causando BufferOverflow no segundo argumento, devido a este ter um espaco de memoria reservado muito pequeno. A solucao e reservar o numero maximo de bytes que um caminho pode ter, assim o segundo argumento tera que ser igual a PATH_MAX mais um
scanf;BufferOverflow;E nescessario controlar o numero de dados lidos para nao escrever por cima de outros dados existentes na memoria. uma solucao e utilizar o fgets(). Se mesmo assim pretender usar a funcao, entao use os seguintes truques (..., "%20%", ...) - onde vinte e o numero de bytes que a funcao vai ler ou (..., "%as", &string).
sscanf;BufferOverflow;E preciso garantir que so le o numero de dados pretendidos, para nao sobrescrever na memoria.  Se mesmo assim pretender usar a funcao, entao use os seguintes truques (..., "%20%", ...) - onde vinte e o numero de bytes que a funcao vai ler ou (..., "%as", &string).
srtcat;BufferOverflow;Utilziar a funcao strncat() ou strcat(), porque contem o numero de dados a concatenar com o destino. uma ma utilizacao provoca BufferOverflow.
strcpy;BufferOverflow;Utilizar a funcao strncpy() ou strlcpy(), porque tem o valor maximo a copiar para o destino, uma ma utilizacao provoca BufferOverflow.
streadd;BufferOverflow;Deve-se garantir que a String de destino e o suficiente para guardar todo o conteudo a tratar da String de origem.
strecpy;BufferOverflow;Deve-se garantir que a String de destino é o suficiente para guardar todo o conteúdo a tratar da String de origem
strtrns;BufferOverflow;Garantir que a String irá guardar o resultado da troca de caracteres antigos por novos tenha espaço suficiente para permitacao, A solucao passa por reservar espaco de memoria suficiente para guardar o resultado da funcao.
vfscanf;BufferOverflow;E preciso garantir que so le o numero de dados pretendidos, para nao sobrescrever na memoria.  Se mesmo assim pretender usar a funcao, entao use os seguintes truques (..., "%20%", ...) - onde vinte e o numero de bytes que a funcao vai ler ou (..., "%as", &string).
strcmp;Terminator_Missing;Sempre que se compara duas Strings, deve-se ter presente nas duas o terminador de fim de uma String. A solucao e garantir que o terminador "\0" se encontra no fim de cada String.
chgrp;Race_Condition;O problema associado a funcao e designado por TOC-TOU, onde se verifica antes de usar e depois usa-se a funcao. o problema e o tempo entre verificar e usar , que um atacante pode modificar o ficheiro para um atalho, ao qual o atalho pode estar associado a um programa malicioso, Uma solucao e eliminar a verificacao e utilizar o fchgrp().
chmod;Race_Condition;No instante que o programa se encontra a executar o chmod(), um atacante muda o ficheiro alvo para um ficheiro de atalho, ao qual o atalho pode ser direcionado para um programa malicioso. Uma solucao passa por eliminar a validacao ao ficheiro alvo e utilizar flags como S_IRUSR|S_IRGRP| S_IROTH. Se possivel utilizar fchmod().
chown;Race_Condition;O problema associado a funcao e designado por TOC-TOU, onde se verifica antes de usar e depois usa-se a funcao. o problema e o tempo entre verificar e usar , que um atacante pode modificar o ficheiro para um atalho, ao qual o atalho pode estar associado a um programa malicioso, Uma solucao e eliminar a verificacao e utilizar o fchown().
vsprinf;BufferOverflow;E preciso garantir que so se le o numero de dados pretendidos, para evitar o BufferOverflow.
vsscanf;BufferOverflow ;E preciso garantir que so le o numero de dados pretendidos, para nao sobrescrever na memoria.  Se mesmo assim pretender usar a funcao, entao use os seguintes truques (..., "%20%", ...) - onde vinte e o numero de bytes que a funcao vai ler ou (..., "%as", &string).
access;Race_Condition;Utilizar a funcao lstat() , de modo a verificar se o ficheiro nao e um atalho(symbolic link).
acct;Race_Condition;Caso o argumento da funcao seja passado como NULL, entao ira desactivar todos os registros de contas. A solucao e nao permitir que um intruso possa indicar o caminho do ficheiro, e nao pode ter controle sobre a especificacao de caminhos, em qualquer outro lugar o programa.
symlink;Race_Condition;Devido a vulnerabilidade TOCTOU, um atacando pode indicar outro ficheiro em vez do pretendido na realidade. A solucao passa por utilizar o lstat(), guardar a estrutura de dados, depois abre-se o ficheiro com o open() e usa-se o fstat() para comparar se o ficheiro nao foi modificado.
tempnam;Race_Condition;O problema associado a funcao e o TOCTOU, como tal deve-se usar de forma muito cautelosa, de modo a um intruso nao modificar o nome. De certa maneira deve-se garantir que o ficheiro gerado e o pretendido e esta somente autorizao para o uso do autor.
tmpfile;Race_Condition; Utilizar a funcao mkstemp(), dado ser mais segura que tmpfile(), sendo menos vulneravel a Race_Condition;.
tempnam;Race_Condition;O problema associado a funcao e o TOCTOU, como tal deve-se usar de forma muito cautelosa, de modo a um intruso nao modificar o nome. De certa maneira deve-se garantir que o ficheiro gerado e o pretendido e esta somente autorizao para o uso do autor.
truncate;Race_Condition;vulnerabilidade de TOCTOU, verifica-se primeiro depois usa-se. A solucao passa por nao utilizar a funcao, e utilizar mecanismos de controle de acesso que algumas funcoes possuem, Se for para trabalhar num ficheiro temporario entao pode-se utilizar o umask() com as permissoes 0066, usar o fopen() com flags propicias, escrever e ler sempre pelo descritor e apagar o ficheiro, depois usa-se o unlink() e fecha-se o descritor, Se possiveis utilizar funlink() e/ou ftruncate().
mkdir;Race_Condition;Tem como problema a vulnerabilidade conhecida por Time of check, Time of use. Uma possível solucao e deixar de verificar antes de usar e depois utilizar algumas flags para tentar eliminar a vulnerabilidade, que sao S IRWXU |S IRWXG IS IROTH IS IXOTH.
mktemp;Race_Condition;O problema associado à função é o TOCTOU. A possível solução seria utilizar o mkstemp().
rename;Race_Condition;Tem associado a vulnerabilidade TOCTOU, onde o programador verifica se o ficheiro e um atalho, se nao então usa a funcao. Entre o verificar e usar, um atacante pode modificar o ficheiro novo para um programa malicioso.Uma solucao assenta em diminuir os privilegios antes do uso da funcao e depois se usa a funcao, apos isto restaura-se os privilegios.
stat;Race_Condition;A esta funcao esta associada o problema TOCTOU. Uma solucao, dado que varia consoante o caso e utilizar o ls-tat () antes de abrir um ficheiro e guardar a estrutura de dados, depois abrir o ficheiro com as flags O CREAT e O_EXCL, de seguida utilizar o fstat () e guardar a es-trutura, por fim compara-se tres elementos da estrutura o st mode, st info e st dev com a estrutura do fstat e Istat, se tudo for valido pode-se editar o ficheiro.
vsprintf;Formatação De String; Limitar os dados a imprimir ou utilizar expressões regulares para eliminar conteúdo impróprio. A forma de limitar os caracteres a imprimir é (..."%20s",...) - onde 20 é o número de caracteres a imprimir.
strlen;Acesso fora dos limites;Assegurar que a cadeia de caracteres tem o carácter "\O".
rand;Numeros-Aleatorios;algoritmo é conhecido e fácil de descobrir o próximo valor aleatório. Utilizar somente srand() ou srandom(),acompanhado com bons seeds.
random;Numeros-Aleatorios;O algoritmo é conhecido e fácil de descobrir o próximovalor aleatório. Utilizar somente srand() ou srandom (), acompanhado com bons seeds
srand;Numeros-Aleatorios;Não utilizar seeds constantes, mas valores aleatórios ou algo semelhante como a hora corrente.
srandom;Numeros-Aleatorios;Não utilizar seeds constantes, mas valores aleatórios ou algo semelhante como a hora corrente.
select;Validacao-de-parametros;A função em conjunto com as macros FD_ SET, FD_ CLR e FD_ISSET, não verifica o valor de fd e quedeve ser verificado do seguinte modo, fd => 0 ou fd <= FD_ SETSIZE.
snprintf;Formatação De String;Alguns sistemas têm esta função a chamar diretamente sprintf0.
sprintf;Formatação De String;Utilizar a função sprintf(), onde se pode limitar os dados impressos. Apesar de alguns sistemas quando é utilizado snprintf() chamam directamente sprintf(). A forma de limitar os caracteres a imprimir é (...,"%20s"...) - onde 20 é o número de caracteres a imprimir
syslog;Formatação De String;Limitar os dados a imprimir ou utilizar expressoes regulares para eliminar conteúdo impróprio. A forma de limitar os caracteres a imprimir é (...,"%20s",...)- onde 20 é o número de caracteres a imprimir.
vfnprintf;Formatação De String;Limitar os dados a imprimir ou utilizar expressoes regulares para eliminar conteúdo impróprio. A forma de limitar os caracteres a imprimir é (...,"%20s",...)- onde 20 é o número de caracteres a imprimir.
vsnprintf;Formatação De String;Limitar os dados a imprimir ou utilizar expressoes regulares para eliminar conteúdo impróprio. A forma de limitar os caracteres a imprimir é (...,"%20s",...)- onde 20 é o número de caracteres a imprimir.
open;Controle-de-Acesso;Sse utiliza o open() para criar um ficheiro novo, então deve-se utilizar a função com o modo O _EXCL|O_CREAT.
popen;Controle-de-Acesso;Devido a possíveis alterações nas variáveis de ambiente.
system;Controle-de-Acesso;Utilizar o exec() para evitar a invocação de uma consola de comandos, a partir do system ().
umask;Controle-de-Acesso;Utilizar sempre o umask() para o "mundo" e grupos, estes não podem ler, escrever ou executar o ficheiro em causa.
fprintf;Formatação De String;Limitar os dados a imprimir ou utilizar expressoes regulares para eliminar conteúdo impróprio. A forma de limitar os caracteres a imprimir é (...,"%20s",...)- onde 20 é o número de caracteres a imprimir.
printf;Formatação De String;Limitar os dados a imprimir ou utilizar expressoes regulares para eliminar conteúdo impróprio. A forma de limitar os caracteres a imprimir é (...,"%20s",...)- onde 20 é o número de caracteres a imprimir.
unlink;Race_Condition;Devido há vulnerabilidade TOCTOU, não se deve usar unlink() e utilizar Istat(), depois usa-se o open() e o fs-tat (), se a comparação dos dados das duas estruturas estiver correcta usa-se o ficheiro, após isto fecha-se fclose () e utiliza-se o unlink().
utime;Race_Condition;A vulnerabilidade TOCTOU provoca problema com a utilização do utime(). Para evitar utilize o futimes().
utimes;Race_Condition;A vulnerabilidade TOCTOU provoca problema com a utilização do utimes(). Para evitar utilize o futimes().
chroot;Controle-de-acesso;Depois de executar a função chroot(), deve-se executar a função chdir().
execlp;Controle-de-acesso;Esta função utiliza a variável de ambiente PATH. A solução pode passar pela diminuição dos privilégios e nunca deixar o utilizador inserir conteúdo para os argumentos da função.
execvp;Controle-de-acesso;Esta função utiliza a variável de ambiente PATH. A solução pode passar pela diminuição dos privilégios e nunca deixar o utilizador inserir conteúdo para os argumentos da função.