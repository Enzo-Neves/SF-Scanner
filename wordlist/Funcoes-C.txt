bcopy;BufferOverflow;Falha em garantir que o caracter de terminação nao se encontra presente no destino. Uma solucao que melhora substancialmente o problema e utilizar o memcpy().
fscanf;BufferOverflow;E preciso garantir que so se le o numero de dados pretendidos, para nao sobrescrever na memoria. Se mesmo assim pretender usar a funcao, entao use os seguintes "truques" , (...,"%20s",...) - onde vinte e o numero de bytes que a funcao vai ler ou (...,"%as",&string).
getcwd;BufferOverflow;O ponteiro de String nao pode ser NULL, caso contrario tem comportamentos diversos.
getopt;BufferOverflow;Problema quando o numero e tamanho dos argumentos e maior do que o esperado, para tal basta verificar o numero e tamanho dos argumentos recebidos
getpass;BufferOverflow;O problema e baseado na falta do caracter de terminacao ("\0"). Por isso, a solucao e garantir que a cadeia de caracteres tem o caracter de terminacao
gets;BufferOverflow;Utilizar a funcao fgets(), dado que tem o valor maximo a ler de dados, Uma ma utilizacao provoca BufferOverflow.
getwd;BufferOverflow;A String deve ser maior que o tamanho da directoria corrente mais um. A solucao possivel e utilizar getcwd(), que obriga o usuario a especificar o tamanho.
realpath;BufferOverflow;O valor introduzido no primeiro argumento pode indicar um caminho muito grande causando BufferOverflow no segundo argumento, devido a este ter um espaco de memoria reservado muito pequeno. A solucao e reservar o numero maximo de bytes que um caminho pode ter, assim o segundo argumento tera que ser igual a PATH_MAX mais um
scanf;BufferOverflow;E nescessario controlar o numero de dados lidos para nao escrever por cima de outros dados existentes na memoria. uma solucao e utilizar o fgets(). Se mesmo assim pretender usar a funcao, entao use os seguintes truques (..., "%20%", ...) - onde vinte e o numero de bytes que a funcao vai ler ou (..., "%as", &string).
sscanf;BufferOverflow;E preciso garantir que so le o numero de dados pretendidos, para nao sobrescrever na memoria.  Se mesmo assim pretender usar a funcao, entao use os seguintes truques (..., "%20%", ...) - onde vinte e o numero de bytes que a funcao vai ler ou (..., "%as", &string).
srtcat;BufferOverflow;Utilziar a funcao strncat() ou strcat(), porque contem o numero de dados a concatenar com o destino. uma ma utilizacao provoca BufferOverflow.
strcpy;BufferOverflow;Utilizar a funcao strncpy() ou strlcpy(), porque tem o valor maximo a copiar para o destino, uma ma utilizacao provoca BufferOverflow.
streadd;BufferOverflow;Deve-se garantir que a String de destino e o suficiente para guardar todo o conteudo a tratar da String de origem.
strecpy;BufferOverflow;Deve-se garantir que a String de destino é o suficiente para guardar todo o conteúdo a tratar da String de origem
strtrns;BufferOverflow;Garantir que a String irá guardar o resultado da troca de caracteres antigos por novos tenha espaço suficiente para permitacao, A solucao passa por reservar espaco de memoria suficiente para guardar o resultado da funcao.
vfscanf;BufferOverflow;E preciso garantir que so le o numero de dados pretendidos, para nao sobrescrever na memoria.  Se mesmo assim pretender usar a funcao, entao use os seguintes truques (..., "%20%", ...) - onde vinte e o numero de bytes que a funcao vai ler ou (..., "%as", &string).
strcmp;Terminator_Missing;Sempre que se compara duas Strings, deve-se ter presente nas duas o terminador de fim de uma String. A solucao e garantir que o terminador "\0" se encontra no fim de cada String.
chgrp;Race_Condition;O problema associado a funcao e designado por TOC-TOU, onde se verifica antes de usar e depois usa-se a funcao. o problema e o tempo entre verificar e usar , que um atacante pode modificar o ficheiro para um atalho, ao qual o atalho pode estar associado a um programa malicioso, Uma solucao e eliminar a verificacao e utilizar o fchgrp().
chmod;Race_Condition;No instante que o programa se encontra a executar o chmod(), um atacante muda o ficheiro alvo para um ficheiro de atalho, ao qual o atalho pode ser direcionado para um programa malicioso. Uma solucao passa por eliminar a validacao ao ficheiro alvo e utilizar flags como S_IRUSR|S_IRGRP| S_IROTH. Se possivel utilizar fchmod().
chown;Race_Condition;O problema associado a funcao e designado por TOC-TOU, onde se verifica antes de usar e depois usa-se a funcao. o problema e o tempo entre verificar e usar , que um atacante pode modificar o ficheiro para um atalho, ao qual o atalho pode estar associado a um programa malicioso, Uma solucao e eliminar a verificacao e utilizar o fchown().