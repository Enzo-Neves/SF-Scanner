bcopy BufferOverflow Falha em garantir que o caracter de terminação nao se encontra presente no destino. Uma solucao que melhora substancialmente o problema e utilizar o memcpy().
fscanf BufferOverflow E preciso garantir que so se le o numero de dados pretendidos, para nao sobrescrever na memoria. Se mesmo assim pretender usar a funcao, entao use os seguintes "truques" , (...,"%20s",...) - onde vinte e o numero de bytes que a funcao vai ler ou (...,"%as",&string).
getcwd BufferOverflow O ponteiro de string nao pode ser NULL, caso contrario tem comportamentos diversos.
getopt BufferOverflow Problema quando o numero e tamanho dos argumentos e maior do que o esperado, para tal basta verificar o numero e tamanho dos argumentos recebidos
getpass BufferOverflow O problema e baseado na falta do caracter de terminacao ("\0"). Por isso, a solucao e garantir que a cadeia de caracteres tem o caracter de terminacao
gets BufferOverflow Utilizar a funcao fgets(), dado que tem o valor maximo a ler de dados, Uma ma utilizacao provoca BufferOverflow.
getwd BufferOverflow A String deve ser maior que o tamanho da directoria corrente mais um. A solucao possivel e utilizar getcwd(), que obriga o usuario a especificar o tamanho.
realpath BufferOverflow O valor introduzido no primeiro argumento pode indicar um caminho muito grande causando BufferOverflow no segundo argumento, devido a este ter um espaco de memoria reservado muito pequeno. A solucao e reservar o numero maximo de bytes que um caminho pode ter, assim o segundo argumento tera que ser igual a PATH_MAX mais um
scanf BufferOverflow E nescessario controlar o numero de dados lidos para nao escrever por cima de outros dados existentes na memoria. uma solucao e utilizar o fgets(). Se mesmo assim pretender usar a funcao, entao use os seguintes truques (..., "%20%", ...) - onde vinte e o numero de bytes que a funcao vai ler ou (..., "%as", &string).
sscanf BufferOverflow E preciso garantir que so le o numero de dados pretendidos, para nao sobrescrever na memoria.  Se mesmo assim pretender usar a funcao, entao use os seguintes truques (..., "%20%", ...) - onde vinte e o numero de bytes que a funcao vai ler ou (..., "%as", &string).
srtcat BufferOverflow Utilziar a funcao strncat() ou strcat(), porque contem o numero de dados a concatenar com o destino. uma ma utilizacao provoca BufferOverflow.
strcpy BufferOverflow Utilizar a funcao strncpy() ou strlcpy(), porque tem o valor maximo a copiar para o destino, uma ma utilizacao provoca BufferOverflow.
streadd BufferOverflow Deve-se garantir que a string de destino e o suficiente para guardar todo o conteudo a tratar da string de origem.
strecpy BufferOverflow
strtrns BufferOverflow
vfscanf BufferOverflow
strcmp
chgrp
chmod
chown
vscanf
vsprinf
vsscanf
access
acct
symlink
tempnam
tmpfile
tempnam
truncate
mkdir
mktemp
rename
stat
vsprintf
strlen
rand
random
srand
srandom
select
snprintf
sprintf
syslog
vfnprintf
vsnprintf
open
popen
system
umask
fprintf
printf
unlink
utime
utimes
chroot
execlp
execvp